# Experiment with WebGL UI and an LLM prompt

The intention behind this code is to develop a simplistic finite-state-machine (FSM) driven GUI where the FSM is generated by an LLM. The LLM generates the FSM from a prompt originating from something like a server.

By mapping the 'state' of a session on the server, we can automatically drive a user interface. The output of such an interface can then 'map' to a value expected by the server to update the session state. And so on...

In this case, by 'state' I mean how a user might model the options they have to go from A to B. The state could be defined in any way, including natural language. The addition of instructions to translate the FSM data into any other language is also demonstrated by the example outputs I've provided.

### Code

All the code in this is primarily taken from examples and module code available in the [three.js](http://github.com/mrdoob/three.js) codebase. Only a small amount of additional code was added to create the state machine system, animations, and basic glue code.

The JSON data included in this repo is actual output from ChatGPT. I also tried to generate similar output locally using [llamafile](https://github.com/Mozilla-Ocho/llamafile) with Mistral 7B but could not get it close enough.

### Example of the full prompt I used

I need you to transform the following text into a JSON structure. You must only return JSON data. Do not ever respond with anything other than JSON data that conforms to the structure I will describe. The JSON structure is this:
```
{
  "state_machine": {
    "000": {
      "option 1": "001",
      "option 2": "002",
      "option 3": "003"
    },
    "001": "emit",
    "002": "emit",
    "001": "emit",
  },
  "value_map": {
    "001": "1",
    "002": "2",
    "003": "3"
  }
}
```
The structure I've just described is an example of the following definition. The state machine is a dictionary of keys mapped to either a dictionary or the word 'emit'. Those keys that map to a dictionary contain keys which are values to be presented in a user-interface. The values of these keys map to keys within the state machine. If the state machine is meant to reach a terminal state, then the key will map to the word 'emit' such that the user interface should know to emit this key and no longer present options to the user. The value map maps the emitted terminal value to another value. The mapping is used to relate the state machine back to the original expected form presented to you when generating this JSON data.

The form presented to you will be natural language. You must translate this natural language into the JSON structure provided. For example, this natural language input, might produce the example JSON I described earlier:

You have 3 options. Once you've selected one of the options, you must respond with either 1, 2, or 3. The options you have are: option 1; option 2; option 3.

Therefore once the user interface has interpreted the state machine and emitted a final value, the final value (either, "001", "002", or "003") can be mapped back to one of the input's requested response values (either "1", "2", or "3"). I repeat, terminal states should be mapped to the keyword 'emit'. The state which maps to the 'emit' keyword should then map to the intended response in the value_map. For example, "001" should map to "emit", while in the value map "001" should be a key and its value should be "1".

**[Note the following line is optionally included to translate the UI]**
One additional requirement is you must translate the user interface information (such as "option 1") above into (German|Mandarin|etc).

The following is the input you need to produce JSON data for:

**[Note from this point onwards, the prompt is expected to change based on what the server provides]**
We start with 2 options. The first is, "I like to dance". The second options is, "I like to sing". If you like dancing, that's all we need to know, so respond with "Dancing is fun!". If you like to sing, you have 2 more options. "I sing loud" is the first option. The second option is "I sing softly". If you sing loud, respond with "Go for it!". If you sing softly, you have 2 final options. The first option now is "to myself" and the second is "with others". Here, you will need to respond with "Have fun!" or "Let's sing!".
